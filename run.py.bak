import gradio as gr
import torch
import torchaudio
import os
import ffmpeg
import time
from transformers import pipeline
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_ollama import ChatOllama
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

# model_name = "scb10x/monsoon-whisper-medium-gigaspeech2"
model_name = "biodatlab/whisper-th-large-v3-combined"
lang = "th"  # Thai language

device = "cuda:0" if torch.cuda.is_available() else "cpu"

pipe = pipeline(
    "automatic-speech-recognition",
    model=model_name,
    chunk_length_s=30,
    device=device,
    return_timestamps=True,
)
pipe.model.config.forced_decoder_ids = pipe.tokenizer.get_decoder_prompt_ids(
  language=lang,
  task="transcribe"
)

def transcribe_speech(filepath):
    # Load the .wav file using torchaudio
    waveform, sample_rate = torchaudio.load(filepath)

    # If the audio is stereo, convert it to mono by averaging the channels
    if waveform.shape[0] == 2:
        waveform = torch.mean(waveform, dim=0, keepdim=True)

    # Ensure the waveform is in the expected format
    audio = {"array": waveform.squeeze().numpy(), "sampling_rate": sample_rate}

    output = pipe(
        audio,
        batch_size=8,
    )
    return output["text"]

def llm_chain(input_text):

    text_splitter = RecursiveCharacterTextSplitter(
        separators=[
            "\n\n",
            "\n",
            " ",
            ".",
            ",",
            "\u200b",  # Zero-width space
            "\uff0c",  # Fullwidth comma
            "\u3001",  # Ideographic comma
            "\uff0e",  # Fullwidth full stop
            "\u3002",  # Ideographic full stop
            "",
        ],
        chunk_size=10000,
        chunk_overlap=0,
        length_function=len,
        is_separator_regex=False,
    )

    prompt = ChatPromptTemplate.from_template(
        """You are text corrector and editor for editing transcription of meeting record.
        Your task are
        - split the text into paragraph
        - add newline between sentences
        - change spell out number into number (0-9)
        by retain the original transcript text as much as possible.
        Retain the language as original one (Thai).
        DO NOT summarize or add any comment.
        Process this text
        
        {text}"""
    )

    llm = ChatOllama(
        # model="gemma2-27b-q8-8k:latest",
        model="qwen2.5:14b-instruct-q8_0",
        temperature=0,
        # other params...
    )

    chain = prompt | llm | StrOutputParser()

    chunks = text_splitter.split_text(input_text)
    output_text = chain.invoke({"text": "".join(chunks)})
    # output_text = "".join(chain.batch(chunks))

    return output_text

def extract_and_transcribe(video_filepath, start_time, end_time):

    log_start_time = time.time()

    # create tmp directory for intermediate audio file
    if not os.path.exists('./tmp/'):
        os.makedirs('./tmp/')

    # extract 1-channel, sample rate 16000, audio from sliced video (0,0 for no slicing)
    if start_time == 0 and end_time == 0:
        out, _ = (ffmpeg
        .input(video_filepath)
        .output('./tmp/output.wav', ac=1, ar='16k')
        .overwrite_output()
        .run(capture_stdout=True)
        )
    else:
        out, _ = (ffmpeg
        .input(video_filepath, ss=start_time, t=end_time-start_time)
        .output('./tmp/output.wav', ac=1, ar='16k')
        .overwrite_output()
        .run(capture_stdout=True)
        )

    output = transcribe_speech('./tmp/output.wav')

    output_text = llm_chain(output)
    
    log_run_time = time.time() - log_start_time

    return output_text, log_run_time

# Build Gradio interface
interface = gr.Interface(
    extract_and_transcribe, 
    [
        gr.Video(label="Upload Video (.mp4)"), 
        gr.Number(label="Start Time (in seconds)"), 
        gr.Number(label="End Time (in seconds)\n0 for both Start and End Time for extract all")
    ], 
    [
        gr.TextArea(label="Transcription", lines=20, autoscroll=False, show_copy_button=True), 
        gr.Number(label="Total run time : (in seconds)", precision=2),
    ]
)

if __name__ == "__main__":
    # Launch the interface
    interface.launch()
